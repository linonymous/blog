<div class="post-body entry-content float-container" id="post-body-5402337769717452464">
<p>All of us surely have come across bunch of systems that supports live commenting. For example, facebook live commenting, twitch/youtube live stream commenting, reddit live stream commenting etc. Lets deep dive in the system that support the live commenting feature.</p><h3 style="text-align: left;"><b>Requirements:</b></h3><div><ul style="text-align: left;"><li>User should be able to see active real time comments on the post/video/stream across the globe.</li><li>System should be highly available, fault tolerant. </li><li>Due to CAP theorem, we will need to trade the consistency. Consider our system to be eventually consistent. If the comment is made, its okay for us if it takes few seconds to appear everywhere else.</li></ul><h3 style="text-align: left;"><b>Goal:</b></h3><div><ul style="text-align: left;"><li>to build a system to sync live comments across the demographies &amp; data centers</li><li>to build a system that supports the real time pushing of comments to the web/mobile clients.</li></ul></div><h3 style="text-align: left;"><b>Estimation:</b></h3></div><div><ul style="text-align: left;"><li>Consider 100M Daily Active Users (DAU), 400M daily posts/videos/streams on the system and daily 10B comments being made on different streams/videos/posts. </li><li>To support such high scale we need a robust &amp; scalable system.</li></ul></div><h3 style="text-align: left;">Database:</h3><div>As we are only concerned about comments, our database will look something similar as follows:</div><div><p>          <b>Comment</b>(id(PK), user_id(FK), post_id(FK), text, timestamp, metadata)</p><p><b>PK:</b> Primary Key, <b>FK: </b>Foreign Key </p><p>Consider that we only allow the text as a comment and no media can be added to the comment.   </p><h3 style="text-align: left;"><b>APIs in the context:</b></h3><div>Lets write some APIs that supports the live commenting feature: </div><div><ul style="text-align: left;"><li><b>POST</b> /comment?post_id=&lt;post_id&gt; </li></ul><div>          This API adds up the comment to the given post. It also handles the authorization with API key, particularly a JWT token that is refreshed after a while. </div></div><div><br/></div><div><ul style="text-align: left;"><li><b>GET /</b>comments?post_id=&lt;post_id&gt;&amp;page_size=&lt;size&gt;&amp;page_number=&lt;page_no&gt;</li></ul><div>          This API requests the comments to the server for given post_id starting from page_number and returns the list of comments of size max(page_size, size of comments array)</div><div><br/></div><div>These APIs are enough to support our listed requirements.</div><h3 style="text-align: left;">Components:</h3><div style="text-align: left;">To query the latest comments we can use the following query. </div><div style="text-align: left;"><br/></div><div style="text-align: left;"><span style="font-size: x-small;"><b>select * from comments where post_id=&lt;post_id&gt; ORDER BY timestamp DESC LIMIT &lt;page_size&gt; OFFSET 1 </b></span></div></div><div style="text-align: left;"><span style="font-size: x-small;"><br/></span></div><div style="text-align: left;">But this is going to be very expensive given the scale we are targeting for. </div></div><div style="text-align: left;"><br/></div><div style="text-align: left;">Apart from that, a media can be viewed from different parts of the world, so syncing the live comments globally is next challenge. </div><div style="text-align: left;"><br/></div><div style="text-align: left;"><b>Read Locally, Write Globally</b></div><div style="text-align: left;"><b><br/></b></div><div style="text-align: left;">Generally data sync across the continents is performed eventually, meaning, if a user posts a photo in India, &amp; his facebook friend who is accessing a feed from USA, will not be able to see the post immediately. The data will be replicated in some moment, to the nearest servers &amp; then the post will be added to the feed. </div><div style="text-align: left;"><br/></div><div style="text-align: left;">This method is known as <b>Read Locally, Write Globally. </b>i.e. The data is queried from local servers, &amp; updates are eventually asynchronously written globally across different servers. What if we try to use the same approach for Live Commenting feature?</div><div style="text-align: left;"><br/></div><div style="text-align: left;"><ul style="text-align: left;"><li>Number of comments being made globally on popular media videos would be significant in numbers.</li><li>If we depend upon the eventual sync across servers globally, then there might be delay of few minutes &amp; this counters the idea of live commenting. Moreover, the people from same region would be able to see each others comments on live whereas people across regions would not be able to see each others comments till the next sync happens.</li><li>This approach is perhaps better when the system is read heavy. But in the case of live commenting, there are going to be lots of writes &amp; for every single write, there is going to be a read performed. So, we need to look out for an approach that suits the scale of write operations.</li></ul></div><div style="text-align: left;"><br/></div><div style="text-align: left;"><b>Write locally, read Globally</b></div><div style="text-align: left;"><b><br/></b></div><div style="text-align: left;">This is exact opposite of the approach that we just discussed in last paragraph. In this approach, we would write the comments locally, but while querying the comments for a media, the server would ask the fellow servers globally in different continents if they have new comments on the media (which can be done with lastTimestamp approach), and then the local server would aggregate all the comments &amp; return back the responses to the client. </div><div style="text-align: left;"><br/></div><div style="text-align: left;">As compared to previous approach, sync latency of the comments across regions is reduced. As writes are done locally &amp; not replicated across, the system does not get loaded up with the jobs syncing the huge number of writes. This approach suits well for the purpose.</div><div style="text-align: left;"><br/></div><div style="text-align: left;">Next task to think about is how to send these new comments to the users who are currently scrolling through their feed. </div><div style="text-align: left;"><br/></div><div style="text-align: left;">There are two ways to deal with this problem:</div><div style="text-align: left;"><br/></div><div style="text-align: left;">1) Pull (fan out on load)</div><div style="text-align: left;"><ul style="text-align: left;"><li>Client has to request data to servers recurrently. Most of the times, responses to these requests are going to be empty, and will consume lot of unnecessary resources. </li><li>Data might become stale unless a client requests for information. </li><li>To make the live commenting feature appealing to users, minimum latency of 50ms is necessary to make it feel realtime, with this latency it might cause lot of load onto the servers. </li></ul></div><div style="text-align: left;"><br/></div><div style="text-align: left;">2) Push (fan out on write)</div><div style="text-align: left;"><ul style="text-align: left;"><li>Clients has to maintain long poll request with the server. This can also be achieved with websockets.</li><li>Server pushes the information to all persisteny connections. </li><li>Disadvantage is, if there are millions of clients awaiting for same piece of information, might overwhelm the server. This problem can be solved with more servers &amp; consistent hashing with custom keys.</li></ul></div><div style="text-align: left;">Given the use case, the comments should load real time, thus Push method with persistent connection/long poll suit our needs. </div><div style="text-align: left;"><br/></div><div style="text-align: left;">Example architecture:</div><div style="text-align: left;"><br/></div><div style="text-align: left;"><div class="separator" style="clear: both; text-align: center;"><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjc0CGWZDwsyoPcd-9yQZSHDiVYNW_xbUjq-K9t_W_lFct7ffCGYQiTGy6OzeKQcsnAv9sKcVWMgCif9bh6oFoiHqG0tgKtD_yXUhEoOsCv8pfJmUa9knepM4q1GO8thdhEG3RMGDbaLPuF/" style="margin-left: 1em; margin-right: 1em;"><img alt="" data-original-height="1200" data-original-width="2621" src="imagepng"/></a></div><br/><br/></div><br/>Here's a <a href="https://excalidraw.com/#json=6307826930548736,xvowTQmQhmNeIGV7wbMiaw" target="_blank">link</a> to view it in better resolution.</div>
</div>